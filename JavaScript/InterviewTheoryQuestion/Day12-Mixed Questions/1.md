1. Closures
   A closure is a function that remembers its outer variables even after the outer function has finished executing.

```js
function makeCounter() {
  let count = 0;
  return function () {
    count++;
    return count;
  };
}
const counter = makeCounter();
console.log(counter()); // 1
console.log(counter()); // 2
```

2. Promises & Async/Await
   Promises handle asynchronous operations. async/await makes working with promises easier.

```js
function fetchData() {
  return new Promise((resolve) => setTimeout(() => resolve("Done!"), 1000));
}

async function getData() {
  const result = await fetchData();
  console.log(result);
}
getData();
```

3. Prototypes & Inheritance
   JavaScript uses prototype-based inheritance.

```js
function Animal(name) {
  this.name = name;
}
Animal.prototype.speak = function () {
  console.log(`${this.name} makes a noise.`);
};
const dog = new Animal("Dog");
dog.speak();
```

4. The Event Loop
   JavaScript is single-threaded but handles async code using the event loop.

```js
console.log("Start");
setTimeout(() => console.log("Timeout"), 0);
console.log("End");
// Output: Start, End, Timeout
```

5. Modules (ES6)
   Modules help organize code.

   ```js
   // math.js
   export function add(a, b) {
     return a + b;
   }
   ```

// main.js

```js
import { add } from "./math.js";
console.log(add(2, 3));
```

6. Currying & Partial Application
   Transforming a function with multiple arguments into a sequence of functions.

   ```js
   function multiply(a) {
     return function (b) {
       return a * b;
     };
   }
   const double = multiply(2);
   console.log(double(5)); // 10
   ```

7. Functional Programming Concepts
   Immutability, pure functions, higher-order functions.

```js
const arr = [1, 2, 3];
const doubled = arr.map((x) => x * 2); // [2, 4, 6]
```

# Advanced JavaScript Concepts

## 1. Closures

A closure is a function that remembers its outer variables even after the outer function has finished executing.

```javascript
function makeCounter() {
  let count = 0;
  return function () {
    count++;
    return count;
  };
}

const counter = makeCounter();
console.log(counter()); // 1
console.log(counter()); // 2
```

---

## 2. Promises & Async/Await

Promises represent the eventual completion (or failure) of an asynchronous operation.

```javascript
function fetchData() {
  return new Promise((resolve, reject) => {
    setTimeout(() => resolve("Data loaded!"), 1000);
  });
}

fetchData().then((data) => console.log(data)); // Data loaded!
```

Async/await makes working with promises easier:

```javascript
async function loadData() {
  const data = await fetchData();
  console.log(data);
}
loadData(); // Data loaded!
```

---

## 3. Prototypes & Inheritance

JavaScript uses prototype-based inheritance.

```javascript
function Animal(name) {
  this.name = name;
}
Animal.prototype.speak = function () {
  console.log(`${this.name} makes a noise.`);
};

const dog = new Animal("Rex");
dog.speak(); // Rex makes a noise.
```

---

## 4. The `this` Keyword

`this` refers to the object that is executing the current function.

```javascript
const obj = {
  value: 42,
  getValue: function () {
    return this.value;
  },
};
console.log(obj.getValue()); // 42
```

---

## 5. Destructuring & Spread/Rest

Destructuring allows unpacking values from arrays or objects.

```javascript
const [a, b] = [1, 2];
const { x, y } = { x: 10, y: 20 };
```

Spread/rest syntax:

```javascript
const arr1 = [1, 2];
const arr2 = [...arr1, 3, 4]; // [1, 2, 3, 4]

function sum(...numbers) {
  return numbers.reduce((a, b) => a + b, 0);
}
```

---

## 6. Modules (ES6)

Modules help organize code.

```javascript
// math.js
export function add(a, b) {
  return a + b;
}

// main.js
import { add } from "./math.js";
console.log(add(2, 3)); // 5
```

---

## 7. Generators

Generators are functions that can be paused and resumed.

```javascript
function* gen() {
  yield 1;
  yield 2;
  yield 3;
}

const g = gen();
console.log(g.next().value); // 1
console.log(g.next().value); // 2
```

---

## 8. Event Loop & Microtasks

JavaScript is single-threaded and uses an event loop to handle asynchronous code.

```javascript
console.log("Start");
setTimeout(() => console.log("Timeout"), 0);
Promise.resolve().then(() => console.log("Promise"));
console.log("End");
// Output: Start, End,
```
