# Advanced JavaScript Concepts

## 1. Closures

A closure is a function that remembers its outer variables even after the outer function has finished executing.

```javascript
function makeCounter() {
  let count = 0;
  return function () {
    count++;
    return count;
  };
}

const counter = makeCounter();
console.log(counter()); // 1
console.log(counter()); // 2
```

---

## 2. Promises & Async/Await

Promises represent the eventual completion (or failure) of an asynchronous operation.

```javascript
function fetchData() {
  return new Promise((resolve, reject) => {
    setTimeout(() => resolve("Data loaded!"), 1000);
  });
}

fetchData().then((data) => console.log(data)); // Data loaded!
```

Async/await makes working with promises easier:

```javascript
async function loadData() {
  const data = await fetchData();
  console.log(data);
}
loadData(); // Data loaded!
```

---

## 3. Prototypes & Inheritance

JavaScript uses prototype-based inheritance.

```javascript
function Animal(name) {
  this.name = name;
}
Animal.prototype.speak = function () {
  console.log(`${this.name} makes a noise.`);
};

const dog = new Animal("Rex");
dog.speak(); // Rex makes a noise.
```

---

## 4. The `this` Keyword

`this` refers to the object that is executing the current function.

```javascript
const obj = {
  value: 42,
  getValue: function () {
    return this.value;
  },
};
console.log(obj.getValue()); // 42
```

---

## 5. Destructuring & Spread/Rest

Destructuring allows unpacking values from arrays or objects.

```javascript
const [a, b] = [1, 2];
const { x, y } = { x: 10, y: 20 };
```

Spread/rest syntax:

```javascript
const arr1 = [1, 2];
const arr2 = [...arr1, 3, 4]; // [1, 2, 3, 4]

function sum(...numbers) {
  return numbers.reduce((a, b) => a + b, 0);
}
```

---

## 6. Modules (ES6)

Modules help organize code.

```javascript
// math.js
export function add(a, b) {
  return a + b;
}

// main.js
import { add } from "./math.js";
console.log(add(2, 3)); // 5
```

---

## 7. Generators

Generators are functions that can be paused and resumed.

```javascript
function* gen() {
  yield 1;
  yield 2;
  yield 3;
}

const g = gen();
console.log(g.next().value); // 1
console.log(g.next().value); // 2
```

---

## 8. Event Loop & Microtasks

JavaScript is single-threaded and uses an event loop to handle asynchronous code.

```javascript
console.log("Start");
setTimeout(() => console.log("Timeout"), 0);
Promise.resolve().then(() => console.log("Promise"));
console.log("End");
// Output: Start, End,
```
