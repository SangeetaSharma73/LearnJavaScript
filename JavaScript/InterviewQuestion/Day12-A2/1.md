1. Closures
   A closure is a function that remembers its outer variables even after the outer function has finished executing.

```js
function makeCounter() {
  let count = 0;
  return function () {
    count++;
    return count;
  };
}
const counter = makeCounter();
console.log(counter()); // 1
console.log(counter()); // 2
```

2. Promises & Async/Await
   Promises handle asynchronous operations. async/await makes working with promises easier.

```js
function fetchData() {
  return new Promise((resolve) => setTimeout(() => resolve("Done!"), 1000));
}

async function getData() {
  const result = await fetchData();
  console.log(result);
}
getData();
```

3. Prototypes & Inheritance
   JavaScript uses prototype-based inheritance.

```js
function Animal(name) {
  this.name = name;
}
Animal.prototype.speak = function () {
  console.log(`${this.name} makes a noise.`);
};
const dog = new Animal("Dog");
dog.speak();
```

4. The Event Loop
   JavaScript is single-threaded but handles async code using the event loop.

```js
console.log("Start");
setTimeout(() => console.log("Timeout"), 0);
console.log("End");
// Output: Start, End, Timeout
```

5. Modules (ES6)
   Modules help organize code.

   ```js
   // math.js
   export function add(a, b) {
     return a + b;
   }
   ```

// main.js

```js
import { add } from "./math.js";
console.log(add(2, 3));
```

6. Currying & Partial Application
   Transforming a function with multiple arguments into a sequence of functions.

   ```js
   function multiply(a) {
     return function (b) {
       return a * b;
     };
   }
   const double = multiply(2);
   console.log(double(5)); // 10
   ```

7. Functional Programming Concepts
   Immutability, pure functions, higher-order functions.

```js
const arr = [1, 2, 3];
const doubled = arr.map((x) => x * 2); // [2, 4, 6]
```
